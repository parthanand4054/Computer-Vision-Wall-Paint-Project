import SwiftUI
import Compression          // needed for the fallback helper

struct ContentView: View {
    @State private var console = "Fetching‚Ä¶"

    var body: some View {
        ScrollView {
            Text(console)
                .font(.system(.body, design: .monospaced))
                .padding()
        }
        .onAppear { fetch() }
    }

    // MARK: ‚Äì Networking
    private func fetch() {
        guard let url = URL(string:
            "https://developer.api.us.stg.walmart.com/api-proxy/service/COMPASS/SERVICE/v4/embeddings/upc?upc_id=7062240121"
        ) else { return }

        var req = URLRequest(url: url)
        req.httpMethod = "GET"
        req.setValue("YOUR-CONSUMER-ID-HERE",                 // TODO ‚í∂
                     forHTTPHeaderField: "wm_consumer.id")
        req.setValue("Bearer YOUR-JWT-TOKEN-HERE",            // TODO ‚í∑
                     forHTTPHeaderField: "Authorization")

        let session = URLSession(configuration: .default,
                                 delegate: InsecureTLSDelegate(),
                                 delegateQueue: nil)

        session.dataTask(with: req) { data, _, error in
            if let error { log("‚ùå \(error.localizedDescription)"); return }
            guard let data else { log("‚ùå No data"); return }

            // 1Ô∏è‚É£ outer JSON (for context)
            log("‚úÖ Response (outer JSON)\n\(prettyPrintedJSON(from: data) ?? "<non-JSON>")")

            // 2Ô∏è‚É£ dive into the payload
            log(unpackPayload(from: data))
        }.resume()
    }

    private func log(_ text: String) {
        DispatchQueue.main.async { console = text; print(text) }
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// TLS delegate that trusts the staging cert

final class InsecureTLSDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ s: URLSession, didReceive c: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        if let trust = c.protectionSpace.serverTrust {
            completionHandler(.useCredential, URLCredential(trust: trust))
        } else {
            completionHandler(.performDefaultHandling, nil)
        }
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MARK: - Payload decoding helpers

/// Pretty-prints if JSON
private func prettyPrintedJSON(from data: Data) -> String? {
    guard
        let obj = try? JSONSerialization.jsonObject(with: data),
        let pretty = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted),
        let str = String(data: pretty, encoding: .utf8)
    else { return nil }
    return str
}

/// Pull `"payload"` ‚Üí base-64 ‚Üí gunzip/deflate ‚Üí interpret
private func unpackPayload(from root: Data) -> String {
    // 1. parse the wrapper
    guard
        let wrapper = try? JSONSerialization.jsonObject(with: root) as? [String: Any],
        let b64     = wrapper["payload"] as? String,
        let gzData  = Data(base64Encoded: b64)
    else { return "‚ùå no payload or base-64 decode failed" }

    // 2. try Foundation‚Äôs built-in decompressor *if* we‚Äôre on iOS 15+
    var raw: Data? = nil
    if #available(iOS 15.0, *) {
        raw = try? gzData.decompressed(using: .zlib)
    }
    // 3. fallback to manual gunzip if needed
    if raw == nil { raw = gzData.gunzipFallback() }

    guard let bytes = raw else {
        return "‚ùå decompression failed (not zlib/gzip?) ‚Äì raw size \(gzData.count) bytes"
    }

    // 4. JSON?
    if let pretty = prettyPrintedJSON(from: bytes) {
        return "üì¶ Inner payload (JSON, \(bytes.count) bytes)\n\(pretty)"
    }

    // 5. Printable UTF-8?
    if let str = String(data: bytes, encoding: .utf8), str.isMostlyPrintable {
        return "üì¶ Inner payload (UTF-8 text, \(bytes.count) bytes)\n\(str)"
    }

    // 6. Looks like Float32 embedding?
    if bytes.count % 4 == 0 {
        let count = bytes.count / 4
        var floats = [Float](repeating: 0, count: count)
        _ = floats.withUnsafeMutableBytes { bytes.copyBytes(to: $0) }
        let first10 = floats.prefix(10).map { String(format: "%.4f", $0) }.joined(separator: ", ")
        return "üì¶ Inner payload = \(count) Float32 values. First 10 ‚Üí [\(first10)]"
    }

    return "üì¶ Inner payload is \(bytes.count) binary bytes (unknown format)"
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// manuals

/// deflate-only fallback (same as before)
private extension Data {
    func gunzipFallback() -> Data? {
        guard !isEmpty else { return self }
        return withUnsafeBytes { src -> Data? in
            guard let srcBase = src.baseAddress else { return nil }
            let dstCap = count * 4
            let dst = UnsafeMutablePointer<UInt8>.allocate(capacity: dstCap)
            defer { dst.deallocate() }
            let len = compression_decode_buffer(dst, dstCap,
                                                srcBase.assumingMemoryBound(to: UInt8.self), count,
                                                nil, COMPRESSION_ZLIB)
            return len == 0 ? nil : Data(bytes: dst, count: len)
        }
    }
}

/// crude ASCII-printability test
private extension String {
    var isMostlyPrintable: Bool {
        let printable = filter { ($0.asciiValue ?? 0) >= 32 && ($0.asciiValue ?? 0) <= 126 }
        return Double(printable.count) / Double(count) > 0.8
    }
}
