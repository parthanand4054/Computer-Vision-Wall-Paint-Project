import SwiftUI
import Compression      // for the low-level gunzip helper
import zlib             // needed for full GZIP support

struct ContentView: View {
    @State private var console = "Fetching‚Ä¶"

    var body: some View {
        ScrollView {
            Text(console)
                .font(.system(.body, design: .monospaced))
                .padding()
        }
        .onAppear { fetch() }
    }

    // MARK: ‚Äì Networking
    private func fetch() {
        guard let url = URL(string:
            "https://developer.api.us.stg.walmart.com/api-proxy/service/COMPASS/SERVICE/v4/embeddings/upc?upc_id=7062240121"
        ) else { return }

        var req = URLRequest(url: url)
        req.httpMethod = "GET"
        req.setValue("YOUR-CONSUMER-ID-HERE",               // ‚Üê TODO ‚ë†
                     forHTTPHeaderField: "wm_consumer.id")
        req.setValue("Bearer YOUR-JWT-TOKEN-HERE",          // ‚Üê TODO ‚ë°
                     forHTTPHeaderField: "Authorization")

        let session = URLSession(configuration: .default,
                                 delegate: InsecureTLSDelegate(),
                                 delegateQueue: nil)

        session.dataTask(with: req) { data, _, error in
            if let error { log("‚ùå \(error.localizedDescription)"); return }
            guard let data else { log("‚ùå No data"); return }

            // ‚ñ∏ outer wrapper JSON (for context)
            log("‚úÖ Response (outer JSON)\n\(prettyPrintedJSON(from: data) ?? "<non-JSON>")")

            // ‚ñ∏ inner payload
            log(unpackPayload(from: data))
        }.resume()
    }

    private func log(_ text: String) {
        DispatchQueue.main.async { console = text; print(text) }
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MARK: ‚Äì TLS delegate that blindly trusts the staging cert

final class InsecureTLSDelegate: NSObject, URLSessionDelegate {
    func urlSession(_ s: URLSession, didReceive c: URLAuthenticationChallenge,
                    completionHandler: @escaping (URLSession.AuthChallengeDisposition, URLCredential?) -> Void) {
        if let trust = c.protectionSpace.serverTrust {
            completionHandler(.useCredential, URLCredential(trust: trust))
        } else {
            completionHandler(.performDefaultHandling, nil)
        }
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MARK: ‚Äì Payload decoding helpers

/// Pretty-prints if JSON
private func prettyPrintedJSON(from data: Data) -> String? {
    guard
        let obj    = try? JSONSerialization.jsonObject(with: data),
        let pretty = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted),
        let str    = String(data: pretty, encoding: .utf8)
    else { return nil }
    return str
}

/// Pull `"payload"` ‚Üí base-64 ‚Üí gunzip ‚Üí JSON / UTF-8 / Float32 preview
private func unpackPayload(from root: Data) -> String {

    // 1. unwrap & base-64
    guard
        let wrap = try? JSONSerialization.jsonObject(with: root) as? [String: Any],
        let b64  = wrap["payload"] as? String,
        let gz   = Data(base64Encoded: b64)
    else { return "‚ùå no payload or base-64 decode failed" }

    // 2. full gzip inflate (handles header & footer)
    guard let raw = gz.fullGunzip() else {
        return "‚ùå gunzip failed ‚Äì got \(gz.count) bytes"
    }

    // 3. JSON?
    if let pretty = prettyPrintedJSON(from: raw) {
        return "üì¶ Inner payload (JSON, \(raw.count) bytes)\n\(pretty)"
    }

    // 4. UTF-8 text?
    if let str = String(data: raw, encoding: .utf8), str.isMostlyPrintable {
        return "üì¶ Inner payload (text, \(raw.count) bytes)\n\(str)"
    }

    // 5. Looks like Float32 embeddings?
    if raw.count % 4 == 0 {
        let n = raw.count / 4
        var v = [Float](repeating: 0, count: n)
        _ = v.withUnsafeMutableBytes { raw.copyBytes(to: $0) }
        let preview = v.prefix(10).map { String(format: "%.4f", $0) }.joined(separator: ", ")
        return "üì¶ \(n) Float32 values. First 10 ‚Üí [\(preview)]"
    }

    // 6. unknown binary
    return "üì¶ Inner payload is \(raw.count) binary bytes (unknown format)"
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MARK: ‚Äì GZIP helper (works on every iOS version)

private extension Data {
    /// Full GZIP inflator using zlib (windowBits = 16 + MAX_WBITS)
    func fullGunzip() -> Data? {
        guard !isEmpty else { return self }

        var stream = z_stream()
        stream.next_in   = UnsafeMutablePointer<Bytef>(mutating: (self as NSData).bytes.bindMemory(to: Bytef.self, capacity: count))
        stream.avail_in  = uint(count)

        let windowBits = 16 + MAX_WBITS      // +16 = accept gzip header/trailer
        guard inflateInit2_(&stream, Int32(windowBits), ZLIB_VERSION, Int32(MemoryLayout<z_stream>.size)) == Z_OK
        else { return nil }

        var out = Data(capacity: count * 2)
        let chunk = 16 * 1024
        var status: Int32

        repeat {
            var buffer = [UInt8](repeating: 0, count: chunk)
            stream.next_out  = &buffer
            stream.avail_out = uInt(chunk)

            status = inflate(&stream, Z_NO_FLUSH)
            let have = chunk - Int(stream.avail_out)
            out.append(buffer, count: have)

        } while status == Z_OK

        inflateEnd(&stream)
        return status == Z_STREAM_END ? out : nil
    }
}

// crude ASCII-printability test
private extension String {
    var isMostlyPrintable: Bool {
        let printable = filter { ($0.asciiValue ?? 0) >= 32 && ($0.asciiValue ?? 0) <= 126 }
        return Double(printable.count) / Double(count) > 0.8
    }
}
